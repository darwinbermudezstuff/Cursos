caracteristicas
	Portable
	7 puntos
		simple
			no punteros
		moderno
			garbage colection			
		POO
		seguridad de tipo
		versionable
		compatible 
		flexible 
---------------------------------------------------------------------
POO
	 Clase
		Tipo de datos
			Atributo 		Estado
			Metodos 		Comportamientos (algoritmo)
	 Atributo
		Datos que caractriza a los objetos de una clase y determina su estado
	 Metodos
		Toda aquellas acciones que se hacen sobre un objeto de cierta clase
			Encender 
			Acelerar 
	 Objetos		
		Plano 			Clase
		Edificio 		Objeto se construye apartir de la clase
	 Instacia
		Cuando instanciamos un objeto se crea la instancia 
	 
	Pilares de POO
		Encapsulamiento
			Es la capacidad de imposibilitar el acceso a los componenetes de los objetos 
			Trabaja sobre las clases 
			Este funciona mucho mejor cuando se trabajan en variables privadas
						
		Abstraccion
			Es la capacidad de obtener y aislar toda la informacion y cualidades de un objeto que no nos parezcan relevantes, nos permite gestionar la complejidad  
			----
			
		Herencia
			Derivacion : claseADerivar
				Derivar hereda todo de claseAderivar
				
			 
		Polimorfismo
			Capacidad para que varias clases u objetos derivados de otro, reaccionen de manera diferente ante los mismos metodos
				Polomorfismo por
					Herencia 
					Abstraccion
					Interface
---------------------------------------------------------------------
Derivar o extender son palabras sinonimas para herencia
Para las herencias, se usa base(parametro parametros) para trabajar o usar el contructor de la clase heredada
cuando heredamos y el contructor del padre lleva datos, se tiene que hacer lo mismo en la hija es decir crear 
un contructor aunq no estoy seguro si se puede realizar una creacion de contructor vacio para que este no se le pase datos	

Para un buen polimorfismo, en la clase padre se tiene que agregar la palabra reservada VIRTUAL esto genera en el codigo
que se pueda sobre escribir, ahora bien en la clase hija que hereda todos los metodos atributos y demas, se tiene que escribir 
overrider para que pueda realizar la funcion de sobre escribir, el ide de .net lo que realizara es poner la palabra reservada 
base.NombreMetodoPadre(); pero como lo que realizaremos es crear un nuevo metodo se comenta y se realiza todo el codigo que 
se necesita trabajar 

UN polimorfismo es hacer que dos clases se comporten de diferente manera 
---------------------------------------------------------------------
Tipos en C# 
	Tods los tipos de datos son compartidos por todos los leguajes dentro de la plataforma .NET 
		Todos los tipos los hereda de System.Objet. 
		Todos los tipos pueden ser tratados como objetos 
Tipos de datos
	valor ( Intrisecos , Enumerable, Estrutura )
		- se dividen en simple (double, float, chart, boolean y son heredados de la clases, object), estructura, enumeracion
		- intrinsecos enumeraciones estructura
		- char, int, float son predefinidos por el sistema
		- enumerable enum ; estructura struc ; predefinidos por el sistema o el programador y no puede ser nulos 
		- Para los tipo simple existe alias para ser llamados de la clase object como, float, long, int short
		- Struc es similar al tipo CLASS estas llevan contructor pero se guardan en pila 
		- Enum permite utilizar un grupo de constantes a traves de nombres asociados que son representativos que dicah constante 

	refernecia ( Array , Clases, Interfaces, Punteros, Delegados )
		arreglos 
		clases
		interface
		punteros, delegaciones
		- Interface es similar a un clase o una estructura con la salvedad de que todos sus miembros son abstractos es decir no estan 
		definidos no tiene codigo, para esto primero se tiene que crear la clase con sus metodos, luego se declara una variable de tipo 
		interface ya que esta va a ser heredero de la clase que contiene esos metodos, alli se agregan los metodos que tiene su clase que se 
		crea nueva, interface IVolar { metodos }; class CAvion:IVolar { codigo y codigo que implementa el metodo IVolar() }
		las interfaces esta pensadas para representar un aspecto de la realidad que a de ser implementado por una clase que herede la interface  

---------------------------------------------------------------------
Operadores logicos
	Aritmeticos
		simbolo que representa una accion determinadas para una variable o valor
			binarios 
				+-*/%
			Unarios
				++,--,-:
	Operadores relacionales
		=,!=,>,<
	Operadores logicos
		&&, || !
---------------------------------------------------------------------
Estructura de condicioanles 
	
	Variables
		Espacio de memoria 
		Se puede definir como 
			Miembro de una clase 
			Variable Local
			Paramtro de un metodo	
		Las variables por refrencias se define por la palabra reservada NEW 
		Las variables por valor son aquellas que se crean con la igual a su contenido
		Se tiene 7 categorias 	
			Variables estaticas 
			Variables de instancia 
			Variables de elementos ARRAY 
			Variable de parametro por valor 
			Variable de parametro de referencia
			Variable de parametro de salida
			Variables locales
		Variables static o variables de clase
		Aquellas variables que no llevan static son referenciadas como de instancia 
		Los parametros por referencias representan la referencia a una instancia existente de un tipo  
		Las variable ref si retornan un valor en los paramtros es la diferencia con la de parametro por valor, los ref aceptan null, una gran funcionalidad 
		es que si estas variables fueron declaradas con ref aparte de que se tiene que agregar valor (menos con tipo out no es necesario darle un valor por defecto) 
		no es necesario que en el metodo a llamar se tenga que retornar un valor meramente del metodo si no que este realmente ya retorna un valor es decir que si 
		dentro del metodo este es editado en su valor este retornara el nuevo valor ahora bien es interesante que out funcione de la misma manera solamente que este 
		antes puede tener asingado valor o no a la hora de enviarlo por el metodo instanciado.
---------------------------------------------------------------------		
	Propiedades:
		Una propiedad es un componente de la clase que combina un campo con los metodos que dan acceso a el 
		las propiedades permiten hacer validaciones sobre las asignaciones y mantener la consistencias de los datos asignados a los campos miembro o de instancia 
		Campo -> private 
		propiedad -> get set
		modificador de accesos + tipo de dato + identificador;
		Aparte de lo anterior requiere especificar un bloque de codigo encerrado entre llevas de apartura y cierre 		
		Para entender un poco en que radica la diferencias de una propiedad y un campo es que por medio del get y set de las propiedades se puede manipualar la data es decir tengo por ejemplo la propuedad 
			public string codigo {
				get { return "CAFETERIA000" + _id; }	// tomando en cuenta que _id es un campo privado que ya existe
				set { _id = int.Parce(value); } 		// Ojo lo que hace esto es mandarle el valor de codigo y se lo asigna a la variable privada de _id 
			}
		
		Caracteristicas
			Accede como si se tratara de un campo No como un metodo
			Permite asociar codigo al momento de leer o escribir un campo 
			No almacenan datos pero se utilizan como si lo hicieran 
			
		Descriptores de acceso  
			Campo o varibel de clase 
			Un campo un icono azul
			para las propiedades un campo de llave
			Restricciones 
				Debe poseer al menos un descriptor de acceso
				El descriptor de acceso puede poseer modificadores de acceso diferente 
				el descriptor get debe poseer un return 
				el descriptor set usa valuee como su parametro
---------------------------------------------------------------------			
	Metodos 
		un conjunto de instrucciones que realiza una tarea especifica y bien definida 
		Los metodos solamente se escriben una vez pero pueden ser invocados en multiples ocaciones durante la ejecucion de un programa 
			ventajas 
				facilita la sepracion de actividades en modulos debidamente identificados 
				organiza de maner legible y facil de entender a los programas 
				facilita al programador la escritura de codigo 
			Clasificacion 
				Procedimientos
					es un metodo que se compone de un conjunto de instrucciones para realizar un proceso, sin embargo, no devuelve algun resultado como producto de su operacion 
					en C# los procedimientos se identifican por su declaracion de tipo void 
					Metodo estatico
						Un metodo estatico puede llamarse sin tener que crear un objeto dicha clase 
						Restricciones 
							No puede utilizar el operador THIS ya que este metodo se puede llamar sin tener que crear un objeto de la clase 
							puede llamar a otro metodo siempre y cuando sea estatico 
				Funciones
					Las funciones son metodos que ejecutan un conjunto de instrucciones e informan del resultado obtenido; es decir, devuelve el dato resultante de la ejecucion
					en C# una funcion utiliza la sentencia return() para devulver el valor corespondeinte 
					Sobre carga de metodos 
						La sobre carga de metodos consiste en crear mas de un procedimeinto, contructor de instancia o propiedad en una clase con el mismo nombre y distinto tipos de argumento 
						Podemos definir varios metodos con el mismo nombre pero con distintos parametros, de forma que el compilador decide a cual se llama dependiendo de los parametros que le lleguen 
						No tenemos que renombrar cada funcion segun el tipo de valor que acepte 
---------------------------------------------------------------------

Modificadores de acceso 
	Dentro del cuerpo de una clase se colocan la declaracion y definicion de todas sus miembros , que podrian ser datos y metodos 
	Los modificadores de acceso indican el nivel de accesibilidad que tendra un miembro o un topo desde otro miembro que la referencie. Existen cuatro modificadores de acceso de C#
		Public 
			Es el modificador menos restrictivo. Si la varible o metodo es delcarada como publica entonces es posible acceder a su contenido desde cualquier objeto de cualquuier tipo 
		Private 
			Los miembros privados solo son accesible dentro de la clase en la que se definen. Solo es posible acceder a su contenido desde los metodos de la clase, pero no desde metodos de las clases derivadas 
		Internal
			 Este indica que aquellos miembros o tipos que se hayan definido con este modificador de acceso solo sera accesible desde los archivos del mismo ensamblado
		Protected
			el modificador protected indica que solo la clase en la que se ha utilizado el modificador y sus clases derivadas tendran acceso al miembro o tipo definido como protected 
	Modificadores de miembros 
		Abstract 
			Se puede utilizar con clase, metodos, propiedades, indizadores y eventos 
			Si en una clase se define miembros marcados con abstract, la clase debera marcarse como abstract
			Las clases marcadas con abstract no se pueden instanciar 
			Una clase no abstracta derivada de una clase abstracta debe incluir implementaciones reales de todos los descriptos de acceso y metodos abstractos heredados 
		Const 
			Se usa para declarar un campo constante o una local constante, los campos y locales constantes no son variables y no se puede modificar 
		Extern
			Se usa para declarar un metodo que se implementa externamente 
		New 
			Este modificador se utiliza en tres situaciones diferentes:
				Operador -> Se utiliza para crear objetos e invocar constuctores.
				Modificador -> Se utiliza para ocultar un miembro heredado de un miembro de clase base
				Restriccion -> Se utiliza para restricgir tipos  que se podrian utilizar como argumentos para una parametros de tipo en una declaracion gneral 
		Override
			Se usa para implementar metodos de clases base marcados como virtual o abstract en las clases derivadas. Al aplicar Override en una clase derivada no se oculta la implementacion en la clase base como sucede con el modificador NEW 
		Partial
			Permite dividir la definicion de miembros en varios archivos dentro del mismo ensamblado, es decir la clase esta definida usando mas de un archivo de codigo fuente 
			Al trabajar en proyectos grandes, el hecho de dividir una clase en archivos independiente permite que varios programadores trabajen al mismo tiempo con ella 
		Readonly
			Se utiliza en campos. Provoca que el campo definido con el modificador Readonly no se pueda modificar fuera de la propia declaracion del campo o del constructor de la clase 
		Sealed
			Se aplica a clases, metodos, propiedade. Los miembros marcados con Sealed no se pueden derivar.
			Permite definir clases que no se pueden heredar 
		Static
			Los miembros a los que se aplica el modificador estatic perteneceran al tipo declarado y no a un objeto especifico
			El modificador static puede utilizar con clases, campos, metodos, propiedades operadores y eventos 
			Los miembros declarados con static tiene la cualidad de solo exitir una ves y no pueden coexitir multiples instancias en memoria al mismo tiempo 
		Unsafe
			Denota un contexto no seguro, que es necesario para cualquier operacion que involucre a punteros 	
		Virtual 
			Al utilizar el modificador virtual sobre un metodo, propiedad, indizador o declaracion de evento, estamos permitiendo que este se pueda sobre escribir en una clase derivada 
		Volatile 
			Indica que varios subprocesos que se ejecutan a la vez pueden modificar un campo.
			Los campos que se declaran como volatil no estan sujetos a optimizaciones del compilador que suponen el acceso por un cubproceso unico 
			Garantiza que el valor mas atualizado esta en todo momento presente en el campo
---------------------------------------------------------------------
Conversiones de tipo
	Una conversion permite convertir los tipos entre si, siempre y cuando sean compatibles 
	la conversion puede realizar de forma explicita o de forma implicita 
	Implisita 
		Ocurre automaticamente 
		Siempre tiene exito
		no se pierde informacion 
	Explicita 
		requiere un casting 
		puede fallar 
		se puede perder informacion 
---------------------------------------------------------------------	
Arrays
Cuando la plataforma .net fue lanzada por primera vez se utilizaban las clases del espacio de nombre System.Collections para almancenar e interactuar con los bits de datos que se utilizan dentro de una aplicacion 
En .net framwork 2.0 el lenguaje de programacion C# mejora para adminitr una caracteristica llamda genericos y con este cambio un nuevo espacio de nomrbes se introdujo en las bibliotecas de clase base: System.Collections.Generic 

La clase Array no forma parte de los espacios de nombres Sytem.Collection. Aun asi, no deja de ser una coleccion, pues se basa en la interfaz Ilist.
El contenedor mas primitivo que se podria utilizar para almancenar los datos de una aplicacion es la matriz o array 
Todas las variables de array de C# reunen una buena parte de la funcionalidad de la clase System.Array 
Un array permite almacenar informacion de muchos elementos en un solo objeto, pudiendo acceder a dicho elementos mediante un indice.
	Son un conjunto de elementos accesibles desde un unico objeto a partir de una posicion especifica }
Los array tiene una cantidad de elementos, todos comienzan en cero y su limite superior sera el numero de elementos totales menos 1 	
Los array pueden ser unidimensionales o multidimensionales
	unidimensionales: un objeto compuesto por multiples elementos, donde cada uno de los elementos tiene una posicion en conjunto 
	multidimensionales: Sigue las mismas normas que un array unifemensional, solamente que sus elementos estan accesibles mediante mas de un indice
	para recorrer en un for los este tipo de arreglo es bueno utilizar la funcion GETUPPERBOUND()
---------------------------------------------------------------------	
Colecciones	

Son unas estructura de datos que nos permiten guardar en su interior cualquuier tipo de informacion. Existen diferentes tipos de colecciones como tambien diferentes forma de almacenar, acceder y de aliminar la informacion 
El .NET Framework define las colecciones en los Namespace 
	System.Collections
	System.Collections.Generic 
Existen dos tipos de coleccion:
	Generica: 
	Un coleccion es un tipo de dato que actua como un contenedor para un conjunto de objetos, esta es mas flexible ya que al momento de crearla no se tiene que especificar el tamaño ni tipo de dato a almacenar
	Son fuertement tipadas
	Son tipos parametrizados: Es aquel que puede definirse sin especificar los tipos de datos de sus parametros en tiempo de compilacion 
	Nos dan la posibilidad de declarar clases, estructuras, metodos e interfaces que actuaran uniformemente sobre valores cuyo tipos se desconocen y son recien especificados al momento de su utilizacion   
		
	No generica: 
	Tiene como caracteristicas que no son fuertemente tipificadas por lo que almecena un dato generico que es objeto. 
	Al momento de almancenar los objetos se convierten en el tipo object y para obtenerlo se deben convertir al dato que necesitamos 
	Colecciones no genericas mas comunes:
		ArrayList: No tiene orden de elementos, es parecido a un arreglo y son obtenido por indice sus elementos 
		Queue (cola): FIFO (First-in First-out) Primero en entrar, primero en salir, se utiliza el metodo "Enqueue" en lugar de Add
		Stack (pila ): LIFO(last-in first-out) Ultimo en entrar, primero en salir, se utiliza metodo "Push" en lugar de add 
		HashTable (tablas): Coleccion de tipo diccionario que almacena los elementos relacionados con un llave KEY en lugar de indice 
		SortedList (lista): Una coleccion tipo diccionario, que almacena los elementos ordenadois por una llave KEY

	Desvetajas principales de la utilizacion de colecciones no genericas 
	Performance: Como almacenan System.Object, cualquier tipo por referencia que agregue a la coleccion sera casteado automaticamente a un object, y cualquier tipo por valor debera ser convertido su correspondiente tipo pro referencia para ser casteado luego a objeto	a esto se le llama BOXIN, los casteos y operaciones de boxin y un boxin necesarias para insertar y obtener elementos de las colecciones no genericas tiene un impacto negativo en la performance de la misma 
	Falta de validacion en tiempo de compilacion: Al almacenar objetos de tipo System.Object, no hay forma de que el complilador valide que los datos que se estan insertando en una coleccion sean validos para la aplicacion 

	ArrayList:
		Guarda la informacion como si fuera una lista. Es un tipo de arreglo que puede cambiar su tamanño segun lo necesitemos.
		Es un clase de C#, por lo tanto tendra metodos o funciones que nos permitiran guardar cualquier tipo de datos.
		El ArrayList tiene una propiedad que llamamos "capacidad". esto indica el tamaño que ocupara el ArrayList tambien tenemos el "conteo" que nos dice los elementos que guarda en su interior 
		db.add(), db.Remove(), db.IndexOf(cadenaABuscar), db.RemoveAt(indice)
		db.addRange(array o lista) = se puede agregar un listado de una sola vez por ejemplo un arreglo completo string[] cliente 
		db.Sort = ordena los elementos de forma acendente; caseinsensitivecompare ().compare(x,y)
	
	Stack (pila):
		A esta coleccion se le conoce como STACK o PILA, nos permite guardar elementos y cambian su tamaño de forma dinamica.
		El STACK es una estructura de tipo LIFO (last-in -- First-out) => ultimo en entrar, primero en salir 
		
		4		<=	7 			7		pop	  		4		=> 		7		
		5						4					5
		3						5					3
		10						3					10
								10		
		
		push(), pop(), peek(), clear(), contains(similaraIndexOf()), count
		la diferencia con peek y pop es que peek solamente toma el dato no lo elimina y pop si lo elimina de la pila 
		
	Queue (cola): 
		Esta coleccion se le conoce tambien como "cola"
		es una estructura de tipo FIFO (First-in First-out) => Primero entrar primero en salir 
		
		4		<=	7 			7		Dequeue	 	7		=> 		10
		5						4					4
		3						5					5
		10						3					3
								10					
		
		Enqueue();   Dequeue(SIN PARAMETRO); PEEK(); contains(similaraIndexOf()), clear(), count,
	
	Diccionarios
		Los diccionarios asignan claves a val9ores cuya caracteristica principal es que el objeto sea accesibel a traves de su llave 
		A diferencia de una lista no puede decirle que me regrese el segundo elemento, pero si puedo decirle que me entregue el valor asociado a "lucas", en cuyo caso el diccionario me regresaria el numero 20
		Algunos diccionarios que posee C# 
			HashTable: 
				un diccionario con pares nombre/valor que pueden ser recuperados por nombre o indice 
				Es una coleccion indexada, tiene un indeice y un valor referenciado a ese indice, el elemento va a depender del valor conocido como "KEY" o "LLAVE"
				El valor contenido en "KEY" es usado para calcular la posicion del elemento en el hashtable. El elemento que va a contener el valor se conoce como "value"
				Add(Key, Value ) => 1. Key sera usado para indexar al elemento, es de cualquier tipo pero general se usa cadena. 2. El valor a insertar tambien puede ser de cualquier tipo.
				Podemos usar el HashTable para guardar un producto con su costo, el nombre del producto puede ser el "key" y su costo sera el "value" 
				Si queremos obtener la pareja de "key-value", nos apoyaremos en una clase conocida como "DictionayEnty", ya que guarda la parejas de datos => Foreach(DictionaryEnty data in miTablita){ data.Key and data.Value}
				Cunado necesitamos leer un elemento en particular del hastable es posible. para usarlo necesitamos colocar el nombre de la instancia de la clase junto con los corchetes y colocamos el KEY que correspoinde al valor que queremos leer en el momento 
				Debemos tener en cuenta que es posible que necesitemos hacer una conversion de valor correspondietnte en el tipo necesario 
				Clear(), Constains(key a buscar), ConstainsValue(), count, Remove(key), 
				
			SortedList: 
				Un diccionario que automaticamente ordena sus elementos por claves 
				Formado por pareja "Key-Value"
				Obtener la clave que se encuentra en el indice "GetKey"
				Obtenemos el valor que se encuentra en el indice especificado con "IndexOfKey" 
				Se ordena el Key automaticamente de forma ascendente 
				Mantiene internamente dos matrices para almacenar los elementos de la lista. Cada elemento es un par clave/valor. Una clave no puede ser null, pero el valor puede ser null 
				Add(), Contains(), ContainsValues(), Remove(), RemoveAt(), SetByIndex() 
				SortedList<TKey, TValue>   
				Internamente, SortedList<Tkey, Tvalue> mantiene dos objetos IList<T> internos, uno para el almacenamiento de claves y otro para el almacenamiento de valores las cuales se acceden mediante un objeto de la clase 
				Metodos -> Add, Remove, RemoveAt, ContainsKey, clear, TryGetValue("Valor", out val)
				Propiedades -> Count, Key, values 
				KeyValuePair<KValue, TValue> para usar con foreach
				  
				
				
			StringDiccionary: 
				Una tabla has con pares nombre/valor implementadas como cadenas de texto fuertemente tipadas 
				
			ListDiccionary: 
				Un diccionario optimizado oara pequenas listas de objetos con alrededor de 10 elementos 
				
			HybrudDiccionary: 
				Un diccionario que usa ListDiccionary para almacenamiento cuando el numero de elementos es pequeno y automaticmanete cambia a Hastable cuando la cantidad es mayor  
				 
	
	
	Las colecciones genericas, tienen la ventaja inmediata de la seguridad de tipos sin necesidad de derivar de un tipo de coleccion base ni de implementar miembros especificos de tipo
		List<T> es la clase generica que se corresponde con ArrayList. 
		Dictionary<TKey, Tvalue> y ConcurrentDictionary<Tkey, TValue> son las clases genericas que se correspoinden con Hastable 
		Las clases genericas Queue<T>, ConcurrentQueue<T>, Stack<T>, ConcurrentStack<T> y SortedList<TKey, TValue> se corresponden con la respectivas clases no genericas de nombre 
		
	Tipos adicionales:
		Hay varios tipos de colecciones genericas que no tiene un tipo homologo no generico. Entre esos tipos se incluyen los siguientes:
			LinkedList<T> es una lista vinculada de uso general que proporciona operaciones de eliminacion e insercion 
			SortedDictionary<TKey, TValue> es un diccionario ordenado con operaciones de elimincion e insercion, lo que lo convierte en una alternativa util a sortedList<TKey, TValue> 
			List<T> Con un objeto de tipo interfaz, tendremos acceso a todos los miembros publicos de la interfaz. Es decir, tendremos acceso a todas las propiedades y metodos queesten definidos en la interfe. En este caso, instanciamos un objeto de tipo clases. Pro lo tanto tendremos acceso a todos los miembros de la interfaz IList<T>, en la definicion de la clase List<T> se implementa la interfaz IList<T> entre otras.
				Add, clear, contains, insert, remove, sort, copacity, count, IndexOf, 
			La diferencia de capacity y count es que capaciti se puede agregar valor esto nos permite darle un limite de valores al LIST
			
	Dictionary
		Una clase Dictionary es una estructura de datos que representa una coleccion de llaves (KEY) y valores de par de datos (value) 
		Dentro de las colecciones convencinales, su homonimo es el HashTable
		No se pueden introducir dos entradas con el mismo valor en el key 
			Podemos bucar un key utilizando su indice
		Podemos acceder a las keys solamente mediante la propiedad Keys del dictionary y a los valores mediante la propiedad values 
		Dictionary<TKey, TValue> 
		Metodos -> Add, Remove, RemoveAt, ContainsKey, clear, TryGetValue("Valor", out val)
		Propiedades -> Count, Key, values 
		El diccionario puede ser utilizado como una matriz para acceder a sus elementos individuales. Es necesario especificar el KEY (no el indice) para obtener su valor  

-------------------------------------------------------


Herencia 
	En C# cualquier dato es un objeto porque todos los tipos derivan implicitamente de este tipo, y "heredan" los metodos y campos definidos en dicha clase 
	La herencia proporcian un mecanismo para definir una nueva clase, a partir de otra que ya existe, modificandola.
	La nueva clase que se define, se denomina clase derivada y la clase de la que se "Hereda" se llama clase base.
	Fundamentos de la herencia: Para indicar que una clase hereda de otra, se utiliza clase nueva : claseBase, La clase derivada "Hereda" todas los miembros de la clase base, es decir, tiene todos y cada uno de los miembros de la clase base y los que el programador desee añadir.
	 Tipos de herencias:
		Dependiendo del numero de clases y de como se relacionen, la herencia puede ser: 
			Simple: 
				Cuando solo se tiene una clase base de la cual hereda la clase derivada, hay herencia simple. 
				La Herencia simple no excluye la posibilidad de que de una misma clase base se pueda derivar mas de una subclase o clase derivada 
			multiple: 
				No es admitida en C#, sin embargo algunos lenguajes de POO si la permiten 
			de niveles multiples:
				Se presenta cuando una clase derivada se usa como base para definir ot6ra clase derivada 
				Es decir, existen diferentes niveles de herencia:
					En el primero, la clase derivada hereda los miembros de una clase base, mientras que en el segundo, la clase derivada funcina a su ves como un clase base y de esta forma comparte con una tercera clase sus propios miembros y los que heredo 
		Una clase derivada no puede acceder a variables y funciones privadas de su clase base 
		Una clase base utiliza normalmente elementos protegidos en lugar de elementos privados 
		Control de acceso a los miembros de la clase base (I)
			Los modifcadores de acceso de los miembros de la superclase y de la subclase definen el encapsulamiento y el interfaz de la clase 
			La forma de acceso a cada uno de los miembros heredados de la clase derivada, depende de los modificades de acceso que cada uno de dichos miembros tenga en la clase base 
			Un miembro de la clase base declarado como Public, pasa a ser un miembro Public en la clase derivada 
			Un miembro declarado como Private en la clase base aunque pertebnces a la clase derivada, no puede ser llamado ni desde propio codigo de la clase derivada ni, por supiesto desde ningun codigo exterior a sy clase 
			Un miembro declarado como Protected, puede ser llamado desde el interior del codigo de la clase derivada pero no desde el exterior de dicha clase, es decir, los objetos de la clase derivada no pueden acceder a ellos 
-----------------------------------------------------------------------			
Clase abstractas y metodos virtuales 
	Una clase abstracta es aquella que forzosamente se ha de derivar si se desea que se puedan crear objetos de la misma o acceder a sus miembros estaticos 
	Para definir una clase abstracta se antepone obstract a su definicion 
	Los metodos abstractos no tienen ninguna implementacion, de modo que la definicion de metodos va seguida por un punto y como en lugar de un bloque de metodo normal.
	Las clases derivadas de la clase abstracta deben implementar tdas los metodos abstractos 
	Cuando una clase abstracta hereda un metodo virtual de una clase base, la clase abstracta puede reemplazar el metodo virtual con un metodo abstracto
	Clases abstractas con elementos abstractos 
		Las clases abstractas pueden definir metodos y propiedades abstractas 
		Los elementos abstractos NO proporcionan implementaciones, solo declaraciones 
	Clase abstracta con elementos virtuales 
		Podemos tambien cambiar dichas definicion en la clase hija. A este topo de metodos se les llama metodos vituales 
	Metodos virtuales: Si en alguna clase hija quisiesemos dar una nueva definicion del <codigo> del metodo, simplemente lo volveremos a definir en la misma pero sistituyendo en su definicion la palabra reservada virtual por override 
---------------------------------------------------------	
Interface 
	La interface es una alternaiva a una clase abstracta 
	Un interface garantiza un determinado comportamiento de una clase o estructura 
	Cuando una clase implementa una interface se garantiza que soportara los metodos, propiedades, eventos e indexadores de la interface.
	Una interface es similar a una clase o a una estructura, pero sus miembros son abstractos, es decir no estan definidos, no tiene codigo.
	Coche es un vehiculo, hereda las caracteristicas y comportamiento de un vehiculo, pero puede tener la capacidad de PoderRegularLaTemperatura(como una casa, por ejemplo)
	Cuando se hereda, se hace referencia a lo que se es, y cuando se implementa una interface se hace referencia a la capacidad de "comportarse" de una determinada manera 
	Una clase que herede de una interface debe implementar todas las definiciones contenidas en ella.
	Los elementos de la interface no llevan los modificadores PUBLIC, VIRTUAL o OBSTRACT 
	Todos los elementos declarados dentro de una interface se consideran publicos y abstractors,
	Si la interface hereda a su vez de otras interfaces, entonces, despues del nombre de la interface se escribe dos puntos (:)
	
